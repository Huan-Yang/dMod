{
    "contents" : "#' Generate the model objects for use in Xs (models with sensitivities)\n#' \n#' @param f Named character vector with the ODE\n#' @param einspline Logical. Use einspline library if set to \\code{TRUE}. Defaults to \\code{FALSE}.\n#' @param ... Further arguments being passed to funC.\n#' @return list with \\code{func} (ODE object) and \\code{extended} (ODE+Sensitivities object)\ngenerateModel <- function(f, einspline=FALSE, modelname = \"f\", ...) {\n  \n  modelname_s <- paste0(modelname, \"_s\")\n  \n  s <- sensitivitiesSymb(f)\n  fs <- c(f, s)\n  \n  \n  if(einspline) {\n    func <- funC.einspline(f, modelname = modelname , ...)\n    extended <- funC.einspline(fs, modelname = modelname_s, ...)\n    \n  }\n  if(!einspline) {\n    func <- cOde::funC(f, modelname = modelname , ...)\n    extended <- cOde::funC(fs, modelname = modelname_s, ...)\n  }\n  \n  list(func = func, extended = extended)\n  \n}\n\n\n#' Generate the model objects for use in Xv (models with input estimation)\n#' \n#' @param f Named character vector with the ODE\n#' @param observed Character vector of the observed states (subset of \\code{names(f)})\n#' @param inputs Character vector of the input function to be estimated as part of the algorithm\n#' @param forcings Character vector of forcings (the input functions that are NOT estimated\n#' as part of the algorithm but still occur as driving force of the ODE)\n#' @param ... Further arguments being passed to funC.\n#' @return list with \\code{func_au} (Combined ODE for states and adjoint sensitivities) and \n#' \\code{func_l} (ODE of the log-likelihood and its gradient)\ngenerateModelIE <- function(f, observed, inputs, forcings, scale=1, modelname = \"f\", ...) {\n  \n  \n  nf <- length(f)\n  ni <- length(inputs)\n  \n  fparse <- getParseData(parse(text=f))\n  variables <- names(f)\n  symbols <- unique(fparse$text[fparse$token == \"SYMBOL\"])\n  forcings.t <- paste(c(forcings, inputs), \"t\", sep=\".\")\n  parameters <- symbols[!symbols%in%c(variables, c(forcings, inputs), forcings.t)]\n    \n  \n  ## Adjoint equtions + Input\n  au <- adjointSymb(f, observed, inputs, parameters)\n  forcings_au <- c(attr(au, \"forcings\"), names(f), c(forcings, inputs))\n  au[1:length(au)] <- replaceSymbols(names(au), paste(scale, names(au), sep=\"*\"), au)\n  au[1:length(au)] <- paste0(\"(\", au[1:length(au)], \")/\", scale)\n  attr(au, \"inputs\") <- replaceSymbols(names(au), paste(scale, names(au), sep=\"*\"), attr(au, \"inputs\"))\n    \n  \n  ## Input estimation equations\n  fa <- c(f, au)\n  fa <- replaceSymbols(inputs, attr(au, \"inputs\"), fa)\n  boundary <- data.frame(name = names(fa),\n                         yini = c(rep(1, nf), rep(NA, nf)),\n                         yend = c(rep(NA, nf), rep(0, nf)))\n  forcings_fa <- c(attr(au, \"forcings\"), forcings)\n  func_fa <- funC.einspline(fa, forcings_fa, jacobian=TRUE, boundary=boundary, modelname = modelname, ...)\n  attr(func_fa, \"inputs\") <- attr(au, \"inputs\")\n  \n  ## Log-likelihood\n  l <- c(attr(au, \"chi\"), attr(au, \"grad\"))\n  forcings_l <- c(names(au), attr(au, \"forcings\"), names(f), c(forcings, inputs))\n  func_l <- funC.einspline(l, forcings_l, modelname = paste0(modelname, \"_l\"), ...)\n  \n  list(func_fa = func_fa, func_l = func_l)\n  \n  \n}\n\n\n#' Return some useful forcing functions as strings\n#' \n#' @param type Which function to be returned\n#' @return String with the function\nforcingsSymb <- function(type =c(\"Gauss\", \"Fermi\", \"1-Fermi\"), parameters = NULL) {\n  \n  type <- match.arg(type)\n  fun <- switch(type,\n                \"Gauss\"   = \"scale*exp(-(time-mu)^2/(2*tau^2))/(tau*2.506628)\",\n                \"Fermi\"   = \"scale/(exp((time-mu)/tau)+1)\",\n                \"1-Fermi\" = \"scale*exp((time-mu)/tau)/(exp((time-mu)/tau)+1)\"         \n  )\n  \n  if(!is.null(parameters)) {\n    fun <- replaceSymbols(names(parameters), parameters, fun)\n  }\n  \n  return(fun)\n  \n}\n\n\nprepareFluxReduction <- function(f) {\n  \n  descr <- attr(f, \"description\")\n  rates <- attr(f, \"rates\")\n  S     <- attr(f, \"SMatrix\")\n  \n  fluxPars <- paste0(\"fluxPar_\", 1:length(rates))\n  rates <- paste0(fluxPars, \"*(\", rates, \")\")\n  data <- cbind(Description = descr, Rate = rates, as.data.frame(S))\n  \n  \n  f <- generateEquations(data)\n  \n  fluxeq <- getFluxEquations(f)\n  \n  fluxEval <- funC.algebraic(fluxeq$fluxVector)\n  \n  attr(f, \"fluxVector\") <- fluxeq$fluxVector\n  attr(f, \"fluxPars\") <- fluxPars\n  attr(f, \"fluxEval\") <- fluxEval\n  \n  return(f)\n  \n  \n}\n\ngetFluxEquations <- function(f) {\n  \n  fluxes.data <- with(attributes(f), {\n    \n    states <- colnames(SMatrix)\n    \n    fluxes <- do.call(rbind, lapply(1:length(states), function(i) {\n      contribution <- which(!is.na(SMatrix[,i] ))\n      data.frame(rate = rates[contribution], state = states[i], sign = SMatrix[contribution, i])\n    }))\n    rownames(fluxes) <- NULL\n    \n    return(fluxes)\n    \n  })\n  \n  fluxes.vector <- with(as.list(fluxes.data), paste0(sign, \"*(\", rate, \")\"))\n  names(fluxes.vector) <- paste(fluxes.data$state, fluxes.data$rate, sep=\".\")\n  fluxes.vector.extended <- c(time = \"time\", fluxes.vector)\n  \n  states <- attr(f, \"species\")\n  fluxes.unique <-as.character(unique(fluxes.data$rate))\n  symbols <- getSymbols(fluxes.unique, exclude = states)\n  nSymbols <- length(symbols)\n  \n  linears <- lapply(1:length(fluxes.unique), function(i) {\n    \n    isLinear <- unlist(lapply(symbols, function(mysymbol) {\n      dflux <- paste(deparse(D(parse(text = fluxes.unique[i]), mysymbol)), collapse=\"\")\n      ddflux <- paste(deparse(D(D(parse(text = fluxes.unique[i]), mysymbol), mysymbol)), collapse=\"\")\n      return(ddflux == \"0\" & dflux != \"0\")\n    }))\n    \n    return(symbols[isLinear])\n    \n    \n  })\n  names(linears) <- fluxes.unique\n  \n  \n  return(list(fluxData = fluxes.data, fluxVector = fluxes.vector, linearContributors = linears))\n  \n}\n\n\n\ngetZeroFluxes <- function(out, rtol = .05, atol = 0) {\n  \n  ## out must have the colnames \"time\", \"state.fluxEquation\"\n  ## states are not allowed to contain a \".\"-symbol\n  \n  states <- sapply(strsplit(colnames(out)[-1], \".\", fixed=TRUE), function(v) v[1])\n  fluxes <- sapply(strsplit(colnames(out)[-1], \".\", fixed=TRUE), function(v) paste(v[-1], collapse=\"\"))\n  unique.states <- unique(states)\n  unique.fluxes <- unique(fluxes)\n  \n  out.groups <- lapply(unique.states, function(s) {\n    \n    selected <- which(states == s)\n    out.selected <- matrix(out[, selected + 1], nrow=dim(out)[1])\n    colnames(out.selected) <- fluxes[selected]\n    \n    # Get L1 norm of fluxes\n    abssum <- apply(abs(out.selected), 2, sum)\n    abssum.extended <- rep(0, length(unique.fluxes))\n    names(abssum.extended) <- unique.fluxes\n    abssum.extended[names(abssum)] <- abssum\n    \n    # Normalize with respect to the L1 norm of the state derivative (sum of all fluxes)\n    state.dot <- apply(out.selected, 1, sum)\n    norm.state.dot <- sum(abs(state.dot))\n    \n    abssum.normed <- abssum/norm.state.dot\n    abssum.normed.extended <- rep(0, length(unique.fluxes))\n    names(abssum.normed.extended) <- unique.fluxes\n    abssum.normed.extended[names(abssum.normed)] <- abssum.normed\n    \n    return(list(abssum.extended, abssum.normed.extended))\n    \n    \n  })\n  \n  out.groups.abs <- do.call(rbind, lapply(out.groups, function(g) g[[1]]))\n  rownames(out.groups.abs) <- unique.states\n  out.groups.rel <- do.call(rbind, lapply(out.groups, function(g) g[[2]]))\n  rownames(out.groups.rel) <- unique.states\n  \n  zero.fluxes.abs <- unique.fluxes[apply(out.groups.abs, 2, function(v) all(v < atol))]\n  zero.fluxes.rel <- unique.fluxes[apply(out.groups.rel, 2, function(v) all(v < rtol))]\n  zero.fluxes <- c(zero.fluxes.abs, zero.fluxes.rel)\n  non.zero.fluxes <- unique.fluxes[!unique.fluxes%in%zero.fluxes]\n  \n  \n  #non.zero.fluxes.rel <- unique.fluxes[apply(out.groups, 2, function(v) any(v > rtol))]\n  \n  zero.parameters <- unlist(lapply(strsplit(zero.fluxes, \"*\", fixed=TRUE), function(v) v[1]))\n  \n  return(list(fluxes.abs = out.groups.abs, \n              fluxes.rel = out.groups.rel, \n              fluxes.zero = zero.fluxes, \n              fluxes.nonzero = non.zero.fluxes, \n              parameters.zero = zero.parameters))\n  \n}\n\n\nnormalizeData <- function(data) {\n  \n  names <- unique(data$name)\n  data.normalized <- do.call(rbind, lapply(names, function(n) {\n    sub <- data[data$name == n,]\n    mean.value <- mean(sub$value)\n    sub$value <- sub$value/mean.value\n    sub$sigma <- sub$sigma/abs(mean.value)\n    return(sub)\n  }))\n  return(data.normalized)\n  \n}\n\nconstraintL2 <- function(p, mu, sigma = 1) {\n  par <- names(mu)\n  t <- p[par]\n  s <- sigma\n  \n  val <- sum((0.5*((t-mu)/s)^2))\n  gr <- rep(0, length(p)); names(gr) <- names(p)\n  gr[par] <- ((t-mu)/(s^2))\n  \n  hs <- matrix(0, length(p), length(p), dimnames = list(names(p), names(p)))\n  diag(hs)[par] <- 1/(s*s)\n  \n  dP <- attr(p, \"deriv\")\n  if(!is.null(dP)) {\n    gr <- as.vector(gr%*%dP); names(gr) <- colnames(dP)\n    hs <- t(dP)%*%hs%*%dP; colnames(hs) <- colnames(dP); rownames(hs) <- colnames(dP)\n  }\n  \n  out <- list(value=val,gradient=gr,hessian=hs)\n  class(out) <- c(\"obj\", \"list\")\n  \n  return(out)\n  \n}\n\n",
    "created" : 1425993951530.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "42806123",
    "id" : "90E823AE",
    "lastKnownWriteTime" : 1425994001,
    "path" : "~/dMod/R/toolsDaniel.R",
    "project_path" : "R/toolsDaniel.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}