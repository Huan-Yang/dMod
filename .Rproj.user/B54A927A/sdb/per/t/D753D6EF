{
    "contents" : "## main functions\n\nfunC <- function(f, ...) UseMethod(\"funC\", f)\nfunC.nospline <- function(...) cOde::funC(...)\n\n#' Generate C code for a function and compile it\n#' \n#' @param f named character vector containing the right-hand sides of the ODE\n#' @param forcings character vector with the names of the forcings\n#' @param jacobian logical indicating whether the jacobian is computed and written into the C file\n#' @param boundary data.frame with columns name, yini, yend specifying the boundary condition set-up. NULL if not a boundary value problem\n#' @param compile logical. If FALSE, only the C file is written\n#' @param nGridpoints numeric. The number of spline interpolation points\n#' @param precision numeric. Defines the inner of the time interval, \\code{(tmin, tmax) = [tmin+precision, tmax-precision]}\n#' @details The function replaces variables by arrays \\code{y[i]}, etc. and replaces \"^\" by pow() \n#' in order to have the correct C syntax. The file name of the C-File is derived from \\code{f}. \n#' I.e. \\code{funC(abc, ...} will generate a file abc.c in the current directory. \n#' Currently, only explicit ODE specification is supported, i.e. you need to have the right-hand sides of the ODE.\n#' In case you have explicitly time-dependent ODEs, please introduce time t as explicit variable, e.g. \\code{f <- c(t = \"1\", x = \"a*t - x\", ...)}.\n#' \n#' The compilation is done via \\code{system(R CMD <modelname>.so -leinspline)}. Therefore, make sure einspline is installed \n#' system-wide.\n#' @return the name of the generated shared object file together with a number of attributes\nfunC.einspline <- function(f, forcings=NULL, jacobian=FALSE, boundary=NULL, compile = TRUE, nGridpoints = 500, precision=1e-5, modelname = NULL) {\n  \n  ## f is a named character vector\n  ## names of f are the variables\n  ## all other symbols are parameters\n  \n  if(is.null(modelname)) modelname <- paste(c(\".f\", sample(c(letters, 0:9), 8, TRUE)), collapse=\"\")\n  dllname <- modelname\n  filename <- paste0(dllname, \".c\")\n  \n  ## If boundary conditions are given, sort for leftbc first\n  if(!is.null(boundary)) {\n    leftbc <- boundary$name[!is.na(boundary$yini)]\n    f <- c(f[names(f)%in%leftbc], f[!names(f)%in%leftbc])\n  }\n    \n  ## Analyze f by parser\n  \n  fparse <- getParseData(parse(text=f))\n  variables <- names(f)\n  symbols <- unique(fparse$text[fparse$token == \"SYMBOL\"])\n  forcings.t <- paste(forcings, \"t\", sep=\".\")\n  parameters <- symbols[!symbols%in%c(variables, forcings, forcings.t, \"time\")]\n  jac <- NULL\n  if(jacobian) jac  <- jacobianSymb(f)\n  not.zero.jac <- which(jac != \"0\")\n  \n  dv <- length(variables)\n  dp <- length(parameters)\n  if(is.null(forcings)) di <- 0 else di <- length(forcings)\n  \n  ## Replace powers and symbols to get correct C syntax\n  \n  f <- replaceOperation(\"^\", \"pow\", f)\n  f <- replaceSymbols(variables, paste0(\"y[\", 1:length(variables)-1, \"]\"), f)\n  f <- replaceSymbols(forcings, paste0(\"x[\", 1:length(forcings)-1, \"]\"), f)\n  f <- replaceSymbols(forcings.t, paste0(\"xdot[\", 1:length(forcings.t)-1, \"]\"), f)\n  \n  if(jacobian) {\n    jac <- replaceOperation(\"^\", \"pow\", jac)\n    jac <- replaceSymbols(variables, paste0(\"y[\", 1:length(variables)-1, \"]\"), jac)\n    jac <- replaceSymbols(forcings, paste0(\"x[\", 1:length(forcings)-1, \"]\"), jac)  \n    jac <- replaceSymbols(forcings.t, paste0(\"xdot[\", 1:length(forcings.t)-1, \"]\"), jac)  \n  }\n  \n  \n  \n    \n  ## ------------ write C code -------------\n  \n  mypath <- system.file(package=\"R2CdeSolve\")\n  splinefile <- paste0(\"cat \", mypath,\"/code/splineCreateEvaluate.c\")\n  includings <- c(\"#include <R.h>\",\n                  \"#include <math.h>\",\n                  \"#include <einspline/nubspline.h>\")\n  definitions <- paste0(\"#define \", c(parameters, paste0(\"y\",0:(dv-1),\"_0\")), \" parms[\", 0:(dv+dp-1),\"]\")\n  \n  sink(filename)\n  cat(\"/** Code auto-generated by R2CdeSolve\", as.character(packageVersion(\"R2CdeSolve\")), \"**/\\n\")\n  cat(paste(includings, \"\\n\"))\n  cat(\"\\n\")\n  cat(paste(\"static double parms[\", dv+dp,\"];\\n\", sep=\"\"))\n  cat(\"static double range[2];\\n\")\n  cat(\"\\n\")\n  cat(paste(\"#define nGridpoints\",nGridpoints,\"\\n\"))\n  cat(paste(\"#define nSplines\", di, \"\\n\"))\n  cat(paste(\"#define precision\", precision, \"\\n\"))\n  cat(\"\\n\")\n  cat(paste(definitions, \"\\n\"))\n  cat(\"#define tmin range[0]\\n\")\n  cat(\"#define tmax range[1]\\n\")\n  cat(\"\\n\")\n  cat(paste(system(splinefile, intern=TRUE), \"\\n\"))\n  cat(\"\\n\")\n  cat(\"void initmod(void (* odeparms)(int *, double *)) {\\n\")\n  cat(paste(\"\\t int N=\", dv+dp,\";\\n\",sep=\"\"))\n  cat(\"\\t odeparms(&N, parms);\\n\")\n  cat(\"}\\n\")\n  cat(\"\\n\")\n  \n  ## Derivative function\n  \n  cat(\"/** Derivatives (ODE system) **/\\n\")\n  cat(\"void derivs (int *n, double *t, double *y, double *ydot, double *RPAR, int *IPAR) {\\n\")\n  cat(\"\\n\")\n  cat(\"\\t double x[nSplines];\\n\")\n  cat(\"\\t double xdot[nSplines];\\n\")\n  cat(\"\\n\")\n  cat(\"\\t evaluateSplines(t, x, xdot);\\n\")\n  cat(\"\\n\")\n  cat(\"double time = *t;\\n\")\n  #if(length(reductions)>0) cat(paste(\"\\t double \", reductions, \";\\n\", sep=\"\"))\n  cat(paste(\"\\t ydot[\", 0:(dv-1),\"] = \", f,\";\\n\", sep=\"\"))\n  cat(\"\\n\")\n  cat(\"}\\n\")\n  cat(\"\\n\")\n    \n  ## Jacobian of deriv\n  if(jacobian) {\n    cat(\"/** Jacobian of the ODE system **/\\n\")\n    cat(\"void jacobian (int * n, double *t, double *y, double * df, double *RPAR, int *IPAR) {\\n\")\n    cat(\"\\n\")\n    cat(\"\\t double x[nSplines];\\n\")\n    cat(\"\\t double xdot[nSplines];\\n\")\n    #cat(paste(\"\\t double ydot[\", dv, \"];\\n\", sep=\"\"))\n    cat(\"\\n\")\n    cat(\"\\t evaluateSplines(t, x, xdot);\\n\")\n    cat(\"\\n\")\n    cat(\"double time = *t;\\n\")\n    #cat(paste(\"\\t ydot[\", 0:(dv-1),\"] = \", f,\";\\n\", sep=\"\"))\n    cat(\"\\n\")\n    cat(\"\\t int i;\\n\")\n    cat(\"for(i=0; i<*n * *n; i++) df[i] = 0;\\n\")\n    cat(paste(\"\\t df[\", not.zero.jac-1,\"] = \", jac[not.zero.jac],\";\\n\", sep=\"\"))\n    cat(\"\\n\")\n    cat(\"}\\n\")\n    cat(\"\\n\")\n  }\n  \n  if(!is.null(boundary)) {\n    \n    ## Check length of boundary conditions\n    nbc <- length(which(!is.na(c(boundary$yini, boundary$yend))))\n    if(nbc != dv) {\n      sink()\n      warning(\"Number of boundary conditions not correct\\n\")\n      return()\n    }\n    \n    boundary <- boundary[match(variables, boundary$name),]\n    \n    leftbc <- which(!is.na(boundary$yini))\n    rightbc <- which(!is.na(boundary$yend))\n    myorder <- c(leftbc, rightbc)\n    \n    ## Boundary Condition (for compatibility with bvpSolve)\n    \n    cat(\"/** Boundary Conditions **/\\n\")\n    cat(\"void gsub(int *i, int *n, double *z, double *g, double *RPAR, int *IPAR) {\\n\")\n    cat(\"\\n\")\n    cat(paste(\"\\t if (*i==\", 1,\") *g=z[\", myorder[1]-1, \"]-y\", 0, \"_0;\\n\", sep=\"\"))\n    if(dv>1) cat(paste(\"\\t else if (*i==\", 2:dv,\") *g=z[\", myorder[-1]-1, \"]-y\", 2:dv-1, \"_0;\\n\", sep=\"\"))\n    cat(\"\\n\")\n    cat(\"}\\n\")\n    cat(\"\\n\")\n    \n    ## Jacobian of Boundary Condition (for compatibility with bvpSolve)\n    \n    cat(\"/** Jacobian of the Boundary Conditions **/\\n\")\n    cat(\"void dgsub(int *i, int *n, double *z, double *dg, double *RPAR, int *IPAR) {\\n\")\n    cat(\"\\n\")\n    cat(\"\\t int j;\\n\")\n    cat(\"\\t for (j = 0; j< *n; j++) dg[j] = 0;\\n\")\n    \n    cat(paste(\"\\t if (*i==\", 1,\") dg[\", myorder[1]-1, \"] = 1.;\\n\", sep=\"\"))\n    if(dv>1) cat(paste(\"\\t else if (*i==\", 2:dv,\") dg[\", myorder[-1]-1, \"]=1.;\\n\", sep=\"\"))\n    cat(\"\\n\")\n    cat(\"}\\n\")\n  }\n  \n  \n  \n  sink()\n  \n  ## ----------- compile C code and load shared object file---------\n  \n  .so <- .Platform$dynlib.ext\n  soExists <- file.exists(paste0(dllname, .so))\n  if(compile) \n    system(paste(\"R CMD SHLIB\", filename, \"-leinspline\"))\n  \n  #dyn.load(paste0(dllname, .so))\n  \n  \n  ## ----------- function return -----------\n  \n  \n  f <- dllname\n  attr(f, \"variables\") <- variables\n  attr(f, \"parameters\") <- parameters\n  attr(f, \"forcings\") <- forcings\n  attr(f, \"jacobian\") <- jacobian\n  attr(f, \"boundary\") <- boundary\n  attr(f, \"nGridpoints\") <- nGridpoints\n  \n  class(f) <- c(\"einspline\", class(f))\n  \n          \n  return(f)\n  \n}\n\n#' Dynamically load DLL with automatic unloading of conflicting DLLs\n#' \n#' @param func result from funC(), contains the information about the DLL name to be loaded\n#' @param cfunction character, denoting the C function name.\n#' @details If the C function name is already part of another loaded DLL, the corresponding DLL is\n#' unloaded and the desired func DLL is loaded instead.\nloadDLL <- function(func, cfunction) {\n  \n  .so <- .Platform$dynlib.ext\n  checkDLL <- try(getNativeSymbolInfo(cfunction), silent=TRUE)\n  if(inherits(checkDLL, \"try-error\")) {\n    dyn.load(paste0(func, .so))\n  } else if((checkDLL$package)[[1]] != func) {\n    #warning(\"Conflicting DLL was unloaded\")\n    dyn.unload(paste0((checkDLL$package)[[1]], .so))\n    dyn.load(paste0(func, .so))\n  }\n  \n}\n\nodeC <- function(y, times, func, parms, ...) UseMethod(\"odeC\", func)\nodeC.nospline <- function(...) cOde::odeC(...)\n\n#' Interface to ode()\n#' \n#' @param y named vector of type numeric. Initial values for the integration\n#' @param times vector of type numeric. Integration times\n#' @param func return value from funC()\n#' @param parms named vector of type numeric. \n#' @param method character, indicating the integration method\n#' @param ... further arguments going to \\code{ode()}\n#' @details See deSolve-package for a full description of possible arguments\n#' @return matrix with times and states\nodeC.einspline <- function(y, times, func, parms, ...) {\n    \n  nGridpoints <- attr(func, \"nGridpoints\")\n  times.inner <- seq(min(c(times, 0)), max(times), len=nGridpoints)\n  times.inner <- sort(unique(c(times, times.inner)))\n  which.times <- match(times, times.inner)\n  \n  loadDLL(func, \"evaluateSplines\")\n    \n  y <- y[attr(func, \"variables\")]\n  parms <- parms[attr(func, \"parameters\")]\n  parms <- c(parms, rep(0, length(y)))\n  if(attr(func, \"jacobian\")) jacfunc <- \"jacobian\" else jacfunc <- NULL\n  \n  arguments <- list(...)\n  if(any(names(arguments)==\"forcings\")) arguments <- arguments[-which(names(arguments)==\"forcings\")]\n  \n  out <- do.call(ode, c(arguments, list(\n    y=y,\n    times=times.inner,\n    func=\"derivs\",\n    parms=parms,\n    dllname=func,\n    initfunc=\"initmod\",\n    jacfunc=jacfunc\n    )))[which.times,]\n \n  \n  return(out)\n  \n}\n\n\nbvptwpC <- function(yini=NULL, x, func, yend=NULL, parms, xguess=NULL, yguess=NULL, forcings = NULL, ...) UseMethod(\"bvptwpC\", func)\nbvptwpC.nospline <- function(...) cOde::bvptwpC\n\n#' Interface to bvptwp()\n#' \n#' \n#' @param yini named vector of type numeric. Initial values to be overwritten.\n#' @param x vector of type numeric. Integration times\n#' @param func return value from funC() with a boundary argument. \n#' @param yend named vector of type numeric. End values to be overwritten.\n#' @param parms named vector of type numeric. The dynamic parameters.\n#' @param xguess vector of type numeric, the x values\n#' @param yguess matrix with as many rows as variables and columns as x values\n#' @param ... further arguments going to \\code{bvptwp()}\n#' @details See bvpSolve-package for a full description of possible arguments\n#' @return matrix with times and states\nbvptwpC.einspline <- function(yini=NULL, x, func, yend=NULL, parms, xguess=NULL, yguess=NULL, ...) {\n  \n  loadDLL(func, \"evaluateSplines\")\n  \n  dynpar <- parms[attr(func, \"parameters\")]\n  boundary <- attr(func, \"boundary\")\n  leftbc <- boundary$name[!is.na(boundary$yini)]\n  rightbc <- boundary$name[!is.na(boundary$yend)]\n  \n  ## Fill yini/yend with values from func. If yini/yend are given,\n  ## set their values.\n  bini <- boundary$yini\n  names(bini) <- boundary$name\n  bini <- bini[!is.na(bini)]\n  \n  bend <- boundary$yend\n  names(bend) <- boundary$name\n  bend <- bend[!is.na(bend)]\n  \n  \n  if(!is.null(yini)) bini[names(yini)] <- yini\n  if(!is.null(yend)) bend[names(yend)] <- yend\n  \n  \n  \n  posbound <- c(rep(min(x), length(bini)), rep(max(x), length(bend)))\n  \n  \n  statepars <- c(bini, bend)\n  newparms <- c(dynpar, statepars)\n  \n  \n  arguments <- list(...)\n  if(any(names(arguments)==\"forcings\")) arguments <- arguments[-which(names(arguments)==\"forcings\")]\n  \n  out <- do.call(bvptwp, c(arguments, list(\n    x = x, parms = newparms, xguess = xguess, yguess = yguess, posbound=posbound,\n    func = \"derivs\", jacfunc = \"jacobian\", bound = \"gsub\", jacbound = \"dgsub\", initfunc = \"initmod\",\n    dllname = func,\n    ncomp = length(statepars)\n  )))\n  \n  \n  colnames(out) <- c(\"x\", attr(func, \"variables\"))\n  \n  return(out)\n  \n  \n}\n\n\n#' Initialize the forcings, i.e. fill the splines used as forcing functions in the C model file\n#' \n#' @details See \\link{setForcings.einspline} and \\link{setForcings.nospline}.\nsetForcings <- function(func, forcings) UseMethod(\"setForcings\", func)\nsetForcings.nospline <- function(...) cOde::setForcings(...)\n\n#' Initialize the forcings, i.e. fill the splines used as forcing functions in the C model file\n#' \n#' @param func The return value of \\link{funC.einspline}\n#' @param forcings A \\code{data.frame} with columns \"name\", \"time\" and \"value\" specifying the \n#' forcing function.\n#' @details Running \\code{setForcings()}, the C function \\code{createSplines()} is called via\n#' the \\code{.C()} interface. In addition, the data frame is translated into a list of matrices\n#' as being encountered when using the forcings interface of the \\code{deSolve} package.\n#' @return A list of matrices with times and values, one matrix for each forcing.\nsetForcings.einspline <- function(func, forcings) {\n  \n  .so <- .Platform$dynlib.ext\n  try(dyn.unload(paste0(func, .so)), silent=TRUE)\n  loadDLL(func, \"createSplines\")\n  \n  inputs <- attr(func, \"forcings\")\n  nGridpoints <- attr(func, \"nGridpoints\")\n  trange <- range(forcings$time)\n  tspan <- seq(trange[1], trange[2], len=nGridpoints)\n  \n  times <- NULL\n  values <- NULL\n  \n  out <- do.call(c, lapply(inputs, function(i) {\n    \n    t <- forcings[forcings$name == i, \"time\"]\n    x <- forcings[forcings$name == i, \"value\"]\n    \n    if(length(t)==1) {\n      t <- seq(tspan[1], tspan[2], len=4)\n      x <- rep(x, 4)\n    }\n    \n    myfun <- splinefun(t, x)\n    out <- myfun(tspan)\n    \n    \n    mat <- list(cbind(tspan, out))\n    names(mat) <- i\n    \n    \n    return(mat)\n    \n  }))\n  \n  \n  times <- do.call(c, lapply(out, function(o) o[,1]))\n  values <- do.call(c, lapply(out, function(o) o[,2]))\n  \n  \n  cfunc <- getNativeSymbolInfo(\"createSplines\")\n  .C(cfunc, as.double(times), as.double(values))\n  \n  return(out)\n  \n  \n  \n  \n}\n                     \n                     \n",
    "created" : 1425993788938.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3753208814",
    "id" : "D753D6EF",
    "lastKnownWriteTime" : 1425994420,
    "path" : "~/dMod/R/R2CdeSolve.R",
    "project_path" : "R/R2CdeSolve.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}