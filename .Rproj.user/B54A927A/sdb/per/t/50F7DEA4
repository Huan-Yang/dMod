{
    "contents" : "\n#' Embed two matrices into one blockdiagonal matrix\n#' \n#' @param M matrix of type character\n#' @param N matrix of type character\n#' @return Matrix of type character containing M and N as upper left and lower right block\nblockdiagSymb <- function(M, N) {\n  \n  red <- sapply(list(M, N), is.null)\n  if(all(red)) {\n    return()\n  } else if(red[1]) {\n    return(N)\n  } else if(red[2]) {\n    return(M)\n  }\n  \n  A <- matrix(0, ncol=dim(N)[2], nrow=dim(M)[1])\n  B <- matrix(0, ncol=dim(M)[2], nrow=dim(N)[1])\n  result <- rbind(cbind(M, A), cbind(B, N))\n  return(result)\n  \n}\n\n\n\n#' Translate wide output format (e.g. from ode) into long format \n#' \n#' @param out data.frame or matrix or list of matrices in wide format \n#' @details The function assumes that out[,1] represents a time-like vector\n#' whereas out[,-1] represents the values. Useful for plotting with ggplot. If \n#' a list is supplied, the names of the list are added as extra column names \"condition\"\n#' @return data.frame in long format, i.e. columns \"time\" (out[,1]), \"name\" (colnames(out[,-1])), \n#' \"value\" (out[,-1]) and, if out was a list, \"condition\" (names(out))\nwide2long <- function(out) {\n  \n  UseMethod(\"wide2long\", out)\n  \n  \n}\n\nwide2long.data.frame <- function(out) {\n  \n  wide2long.matrix(out)\n  \n}\n\nwide2long.matrix <- function(out) {\n  \n  timename <- colnames(out)[1]\n  allnames <- colnames(out)[-1]\n  times <- out[,1]\n  values <- unlist(out[,allnames])\n  outlong <- data.frame(time = times, name = rep(allnames, each=length(times)), value = as.numeric(values))\n  colnames(outlong)[1] <- timename\n  \n  return(outlong)\n  \n}\n\nwide2long.list <- function(out) {\n  \n  conditions <- names(out)\n  \n  outlong <- do.call(rbind, lapply(conditions, function(cond) {\n    \n    myout <- out[[cond]]\n    timename <- colnames(myout)[1]\n    allnames <- colnames(myout)[-1]\n    times <- myout[,1]\n    values <- unlist(myout[,allnames])\n    myoutlong <- data.frame(time = times, \n                            name = rep(allnames, each=length(times)), \n                            value = as.numeric(values), \n                            condition = cond)\n    colnames(myoutlong)[1] <- timename\n    return(myoutlong)\n    \n  }))\n  \n  \n  \n  return(outlong)\n  \n}\n\n\n#' Translate long to wide format (inverse of wide2long.matrix) \n#' \n#' @param out data.frame in long format \n#' @return data.frame in wide format \nlong2wide <- function(out) {\n  \n  timename <- colnames(out)[1]\n  times <- unique(out[,1])\n  allnames <- unique(as.character(out[,2]))\n  M <- matrix(out[,3], nrow=length(times), ncol=length(allnames))\n  M <- cbind(times, M)\n  colnames(M) <- c(timename, allnames)\n  \n  return(M)\n  \n}\n\n\n#' Bind named list of data.frames into one data.frame\n#' \n#' @param mylist A named list of data.frame. The data.frames are expected to have the same structure.\n#' @details Each data.frame ist augented by a \"condition\" column containing the name attributed of\n#' the list entry. Subsequently, the augmented data.frames are bound together by \\code{rbind}.\n#' @return data.frame with the originial columns augmented by a \"condition\" column.\nlbind <- function(mylist) {\n  \n  conditions <- names(mylist)\n  \n  outlong <- do.call(rbind, lapply(conditions, function(cond) {\n    \n    myout <- mylist[[cond]]\n    myoutlong <- cbind(myout, condition = cond)\n    \n    return(myoutlong)\n    \n  }))\n  \n  return(outlong)\n  \n}\n\n\n#' Faster version of expand.grid\n#' \n#' @param seq1 Vector\n#' @param seq1 Vector\n#' @details See \\link{expand.grid} for a description of the functionality.\n#' @return data.frame with the combinations of \\code{seq1} and \\code{seq2}.\nexpand.grid.alt <- function(seq1,seq2) {\n  cbind(Var1=rep.int(seq1, length(seq2)), Var2=rep(seq2, each=length(seq1)))\n}\n\n#' Load a template file in the editor\n#' \n#' @param i Integer, choose a template to be loaded\n#' @details Possible templates are:\n#' i = 1: Do parameter estimation in a dynamic model with fixed forcings\nloadTemplate <- function(i = 1) {\n  \n  path <- path.package(\"R2CdeSolve\")\n  if(i == 1) {\n    system(paste0(\"cp \", path, \"/templates/R2CTemplate.R mymodel.R\"))\n    file.edit(\"mymodel.R\")\n  }\n  if(i == 2) {\n    system(paste0(\"cp \", path, \"/templates/R2CTemplateIE.R mymodelIE.R\"))\n    file.edit(\"mymodelIE.R\")\n  }\n  \n}\n\n\n\nfunC.algebraic <- function(x) {\n  require(inline)\n  \n  # Get symbols to be substituted by x[] and y[]\n  outnames <- names(x)\n  innames <- getSymbols(x)\n  \n  # Do the replacement to obtain C syntax\n  x <- replaceOperation(\"^\", \"pow\", x)\n  x <- replaceSymbols(innames, paste0(\"x[\", (1:length(innames))-1, \"+i* *k]\"), x)\n  names(x) <- paste0(\"y[\", (1:length(outnames)) - 1, \"+i* *l]\")\n  \n  # Paste into equation\n  expr <- paste(names(x), \"=\", x, \";\")\n  \n  # Put equation into loop, body of the C function\n  body <- paste(\n    \"for(int i = 0; i< *n; i++) {\",\n      paste(expr, collapse=\"\"),\n    \"}\"\n  )\n  \n  # Generate the C function by the inline package\n  myCfun <- cfunction(sig=c(x = \"double\", y = \"double\", n = \"integer\", k = \"integer\", l = \"integer\"),\n                     body=body,\n                     language=\"C\",\n                     convention=\".C\"\n                     )\n  \n  # Generate output function\n  myRfun <- function(x) {\n    \n    # Translate the list into matrix and then into vector\n    M <- do.call(rbind, x[innames])\n    if(length(M) == 0) M <- matrix(0)\n    x <- as.double(as.vector(M))\n    \n    # Get integers for the array sizes\n    n <- as.integer(dim(M)[2])\n    k <- as.integer(length(innames))\n    if(length(k) == 0) k <- as.integer(0)\n    l <- as.integer(length(outnames))\n    \n    \n    # Initialize output vector\n    y <- double(l*n)\n    \n    # Evaluate C function and write into matrix\n    out <- matrix(myCfun(x, y, n, k, l)$y, nrow=length(outnames), ncol=n)\n    rownames(out) <- outnames\n    \n    return(t(out))    \n    \n  }\n  \n  \n  return(myRfun)\n  \n}\n",
    "created" : 1425994004776.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1767579112",
    "id" : "50F7DEA4",
    "lastKnownWriteTime" : 1425993698,
    "path" : "~/dMod/R/tools.R",
    "project_path" : "R/tools.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}