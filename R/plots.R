theme_dMod <- function (base_size = 12, base_family = "") {
  colors <- list(
    medium = c(gray = '#737373', red = '#F15A60', green = '#7AC36A', blue = '#5A9BD4', orange = '#FAA75B', purple = '#9E67AB', maroon = '#CE7058', magenta = '#D77FB4'),
    dark = c(black = '#010202', red = '#EE2E2F', green = '#008C48', blue = '#185AA9', orange = '#F47D23', purple = '#662C91', maroon = '#A21D21', magenta = '#B43894'),
    light = c(gray = '#CCCCCC', red = '#F2AFAD', green = '#D9E4AA', blue = '#B8D2EC', orange = '#F3D1B0', purple = '#D5B2D4', maroon = '#DDB9A9', magenta = '#EBC0DA')
  )
  gray <- colors$medium["gray"]
  black <- colors$dark["black"]
  
  theme_bw(base_size = base_size, base_family = base_family) + 
    theme(line = element_line(colour = gray), 
          rect = element_rect(fill = "white", colour = NA), 
          text = element_text(colour = black), 
          axis.ticks = element_line(colour = gray), 
          legend.key = element_rect(colour = NA), 
          panel.border = element_rect(colour = gray), 
          panel.grid = element_line(colour = gray, size = 0.2), 
          strip.background = element_rect(fill = "white", colour = NA))
}

ggplot <- function(...) ggplot2::ggplot(...) + theme_dMod()


#' Plot a list of model predictions
#' 
#' @param prediction Named list of matrices or data.frames, usually the output of a prediction function
#' as generated by \link{Xs}.
#' @param ... Further arguments going to \code{subset}. 
#' @param scales The scales argument of \code{facet_wrap} or \code{facet_grid}, i.e. \code{"free"}, \code{"fixed"}, 
#' \code{"free_x"} or \code{"free_y"}
#' @param facet Either \code{"wrap"} or \code{"grid"}
#' @details The data.frame being plotted has columns \code{time}, \code{value}, \code{name} and \code{condition}.
#'  
#' 
#' @return A plot object of class \code{ggplot}.
#' @export
#' @import ggplot2
plotPrediction <- function(prediction, ..., scales = "free", facet = "wrap") {
  
  prediction <- subset(wide2long.list(prediction), ...)
  
  if(facet == "wrap")
    p <- ggplot(prediction, aes(x = time, y = value, group = condition, color = condition)) + facet_wrap(~name, scales = scales)
  if(facet == "grid")
    p <- ggplot(prediction, aes(x = time, y = value)) + facet_grid(name~condition, scales = scales)
 
  p <- p + geom_line() 
  
  attr(p, "data") <- prediction
  return(p)
   
}


#' Plot a list of model predictions and a list of data points in a combined plot
#' 
#' @param prediction Named list of matrices or data.frames, usually the output of a prediction function
#' as generated by \link{Xs}.
#' @param data Named list of data.frames as being used in \link{res}, i.e. with columns \code{name}, \code{time}, 
#' \code{value} and \code{sigma}.
#' @param ... Further arguments going to \code{subset}. 
#' @param scales The scales argument of \code{facet_wrap} or \code{facet_grid}, i.e. \code{"free"}, \code{"fixed"}, 
#' \code{"free_x"} or \code{"free_y"}
#' @param facet Either \code{"wrap"} or \code{"grid"}
#' @details The data.frame being plotted has columns \code{time}, \code{value}, \code{sigma},
#' \code{name} and \code{condition}.
#'  
#' 
#' @return A plot object of class \code{ggplot}.
#' @export
plotCombined <- function (prediction, data = NULL, ..., scales = "free", facet = "wrap") {
  
  mynames <- c("time", "name", "value", "sigma", "condition")
  
  if(!is.null(prediction)) {
    prediction <- cbind(wide2long(prediction), sigma = NA)
    prediction <- subset(prediction, ...)
  }
  if(!is.null(data)) {
    data <- lbind(data)
    data <- subset(data, ...)
  }
  
  total <- rbind(prediction[, mynames], data[, mynames])
  
  if(facet == "wrap")
    p <- ggplot(total, aes(x = time, y = value, ymin = value - sigma, ymax = value + sigma, 
                           group = condition, color = condition)) + facet_wrap(~name, scales = scales)
  if(facet == "grid")
    p <- ggplot(total, aes(x = time, y = value, ymin = value - sigma, ymax = value + sigma)) + facet_grid(name~condition, scales = scales)
  
  if(!is.null(prediction))
    p <- p +  geom_line(data = prediction)
  
  if(!is.null(data))
    p <- p + geom_point(data = data) + geom_errorbar(data = data, width = 0)
  
  attr(p, "data") <- list(data = data, prediction = prediction)
  return(p)
  
}

#' Plot a list data points
#' 
#' @param data Named list of data.frames as being used in \link{res}, i.e. with columns \code{name}, \code{time}, 
#' \code{value} and \code{sigma}.
#' @param ... Further arguments going to \code{subset}. 
#' @param scales The scales argument of \code{facet_wrap} or \code{facet_grid}, i.e. \code{"free"}, \code{"fixed"}, 
#' \code{"free_x"} or \code{"free_y"}
#' @param facet Either \code{"wrap"} or \code{"grid"}
#' @details The data.frame being plotted has columns \code{time}, \code{value}, \code{sigma},
#' \code{name} and \code{condition}.
#'  
#' 
#' @return A plot object of class \code{ggplot}.
#' @export
plotData <- function (data, ..., scales = "free", facet = "wrap") {
  
  data <- subset(lbind(data), ...)

  if(facet == "wrap")
    p <-  ggplot(data, aes(x = time, y = value, ymin = value - sigma, 
                           ymax = value + sigma, group = condition, color = condition)) + facet_wrap(~name, scales = scales)
  if(facet == "grid")
    p <- ggplot(data, aes(x = time, y = value, ymin = value - sigma, 
                          ymax = value + sigma)) +  facet_grid(name~condition, scales = scales)
  
  p <- p + geom_point() + geom_errorbar(width = 0)
  
  
  attr(p, "data") <- data
  return(p)
  
}

#' Profile likelihood plot
#' 
#' @param ... Lists of profiles as being returned by \link{profile}.
#' @param maxvalue Numeric, the value where profiles are cut off.
#' @param parlist Matrix or data.frame with columns for the parameters to be added to the plot as points.
#' If a "value" column is contained, deltas are calculated with respect to lowest chisquare of profiles.
#' @return A plot object of class \code{ggplot}.
#' @export
plotProfile <- function(..., maxvalue = 5, parlist = NULL) {
  
  
  arglist <- list(...)
  
  data <- do.call(rbind, lapply(1:length(arglist), function(i) {
    proflist <- arglist[[i]]
    do.valueData <- "valueData" %in% colnames(proflist[[1]])
    do.valuePrior <- "valuePrior" %in% colnames(proflist[[1]])
    
    # Discard faulty profiles
    proflistidx <- sapply(proflist, function(prf) grepl(class(prf), "matrix"))
    proflist <- proflist[proflistidx]
    if (sum(!proflistidx) > 0) {
      warning(sum(!proflistidx), " profiles discarded.", call. = FALSE)
    }
    
    subdata <- do.call(rbind, lapply(names(proflist), function(n) {
      
      values <- proflist[[n]][,1]
      zerovalue <- proflist[[n]]["out",1]
      parvalues <- proflist[[n]][,n]
      deltavalues <- values - zerovalue

      sub <- subset(data.frame(name = n, delta = deltavalues, par = parvalues, proflist = i, mode="total", is.zero = rownames(proflist[[n]]) == "out"), delta <= maxvalue)
      if(do.valueData){
        valuesD <- proflist[[n]][,"valueData"]
        zerovalueD <- proflist[[n]]["out","valueData"]
        deltavaluesD <- valuesD - zerovalueD
        sub <- rbind(sub,subset(data.frame(name = n, delta = deltavaluesD, par = parvalues, proflist = i, mode="Data", is.zero = rownames(proflist[[n]]) == "out"), delta <= maxvalue))
      }
      if(do.valuePrior){
        valuesP <- proflist[[n]][,"valuePrior"]
        zerovalueP <- proflist[[n]]["out","valuePrior"]
        deltavaluesP <- valuesP - zerovalueP
        sub <- rbind(sub,subset(data.frame(name = n, delta = deltavaluesP, par = parvalues, proflist = i, mode="Prior", is.zero = rownames(proflist[[n]]) == "out"), delta <= maxvalue))
      }
      return(sub)
    }))
    return(subdata)
  }))
  
  data$proflist <- as.factor(data$proflist)
  data.zero <- subset(data, is.zero)

  threshold <- c(1, 2.7, 3.84)
  
  p <- ggplot(data, aes(x=par, y=delta, group=interaction(proflist,mode), color=proflist, linetype=mode)) + facet_wrap(~name, scales="free_x") + 
    geom_line() + #geom_point(aes=aes(size=1), alpha=1/3) +
    geom_point(data = data.zero) +
    geom_hline(yintercept=threshold, lty=2, color="gray") + 
    ylab(expression(paste("CL /", Delta*chi^2))) +
    scale_y_continuous(breaks=c(1, 2.7, 3.84), labels = c("68% / 1   ", "90% / 2.71", "95% / 3.84")) +
    xlab("parameter value")
  
  if(!is.null(parlist)){
    delta <- 0
    if("value" %in% colnames(parlist)){
      minval <- min(unlist(lapply(1:length(arglist), function(i){ zerovalue <- arglist[[i]][[1]]["out",1]   })))
      values <- parlist[,"value"]
      parlist <- parlist[,!(colnames(parlist) %in% "value")]
      delta <- as.numeric(values - minval)
    }
    points <- data.frame(par = as.numeric(as.matrix(parlist)), name = rep(colnames(parlist), each = nrow(parlist)), delta = delta)

    #points <- data.frame(name = colnames(parlist), par = as.numeric(parlist), delta=0)
    p <- p + geom_point(data=points, aes(x=par, y=delta, group=NULL, linetype = NULL), color = "black")
  }
  attr(p, "data") <- data
  return(p)
  
}

#' Profile likelihood: plot of the parameter paths.
#' 
#' @param ... Lists of profiles as being returned by \link{profile}.
#' @param whichPar Character or index vector, indicating the parameters that are taken as possible reference (x-axis)
#' @param sort Logical. If paths from different parameter profiles are plotted together, possible
#' combinations are either sorted or all combinations are taken as they are.
#' @return A plot object of class \code{ggplot}.
#' @export
plotPaths <- function(..., whichPar = NULL, sort = FALSE, relative = TRUE, scales = "free") {
  
  arglist <- list(...)
  
  
  data <- do.call(rbind, lapply(1:length(arglist), function(i) {
    # choose a proflist
    proflist <- arglist[[i]]
    if(is.null(whichPar)) whichPar <- names(proflist)
    if(is.numeric(whichPar)) whichPar <- names(proflist)[whichPar]
    subdata <- do.call(rbind, lapply(whichPar, function(n) {
      # chose a profile
      paths <- submatrix(proflist[[n]], cols = -(1:4))
      values <- proflist[[n]][,1]
      if(relative) 
        for(j in 1:ncol(paths)) paths[, j] <- paths[, j] - paths[which.min(values), j]
      combinations <- expand.grid.alt(whichPar, colnames(paths))
      if(sort) combinations <- apply(combinations, 1, sort) else combinations <- apply(combinations, 1, identity)
      combinations <- submatrix(combinations, cols = -which(combinations[1,] == combinations[2,]))
      combinations <- submatrix(combinations, cols = !duplicated(paste(combinations[1,], combinations[2,])))
      
      
      
      
      path.data <- do.call(rbind, lapply(1:dim(combinations)[2], function(j) {
        data.frame(chisquare = values, 
                   name = n,
                   proflist = i,
                   combination = paste(combinations[,j], collapse = " -\n "),
                   x = paths[, combinations[1,j]],
                   y = paths[, combinations[2,j]])
      }))
      
      return(path.data)
      
    }))
    
    return(subdata)
    
  }))
  
  data$proflist <- as.factor(data$proflist)
  
  
  if(relative)
    axis.labels <- c(expression(paste(Delta, "parameter 1")), expression(paste(Delta, "parameter 2")))  
  else
    axis.labels <- c("parameter 1", "parameter 2")
  
  
  p <- ggplot(data, aes(x=x, y=y, group=interaction(name, proflist), color=name, lty=proflist)) + 
    facet_wrap(~combination, scales = scales) + 
    geom_path() + geom_point(aes=aes(size=1), alpha=1/3) +
    xlab(axis.labels[1]) + ylab(axis.labels[2]) +
    scale_linetype_discrete(name = "profile\nlist") +
    scale_color_discrete(name = "profiled\nparameter")
  
  attr(p, "data") <- data
  return(p)
  
}




#' Plot an array of model predictions for a list of parameters
#' 
#' @param parlist Matrix or data.frame with a "value" column and columns for the parameters
#' @param x The model prediction function \code{x(times, pars, fixed, ...)}
#' @param times Numeric vector of time points for the model prediction
#' @param data Named list of data.frames as being used in \link{res}, i.e. with columns \code{name}, \code{time}, 
#' \code{value} and \code{sigma}.
#' @param ... Further arguments going to \code{subset}.
#' @param fixed Named numeric vector with fixed parameters
#' @param deriv Logical. If \code{x} supports the argument \code{deriv}, it is used.
#' @param scales The scales argument of \code{facet_wrap} or \code{facet_grid}, i.e. \code{"free"}, \code{"fixed"}, 
#' \code{"free_x"} or \code{"free_y"}
#' @param facet Either \code{"wrap"} or \code{"grid"}
#' @details The data.frame being plotted has columns \code{time}, \code{value}, \code{sigma},
#' \code{name} and \code{condition}.
#'  
#' 
#' @return A plot object of class \code{ggplot}.
#' @export
plotArray <- function(parlist, x, times, data = NULL, ..., fixed = NULL, deriv = FALSE, scales = "free", facet = "wrap") {

  pars<- lapply(1:nrow(parlist), function(i) rev(unlist(parlist[i, ])))
  
  prediction <- lapply(pars, function(p) {
    pred <- x(times, p, fixed, deriv = deriv)
    newnames <- sapply(names(pred), function(cond) paste(colnames(pred[[cond]])[-1], cond, sep = ",\n "))
    pred <- do.call(cbind, pred)
    pred <- pred[, -which(colnames(pred) == "time")]
    pred <- cbind(times, pred)
    colnames(pred) <- c("time", newnames)
    return(pred)
  }); names(prediction) <- parlist[ ,"value"]
  
  
  if(!is.null(data)) {
    for(n in names(data)) data[[n]]$name <- paste(data[[n]]$name, n, sep = ",\n ")
    data <- do.call(rbind, data)
    data <- list(data)
    names(data) <- names(prediction)[1]
  }
  
  plotCombined(prediction, data, ..., scales = scales, facet = facet) 
  
  
}

#' Plot Fluxes given a list of flux Equations
#' 
#' @param pouter parameters
#' @param x The model prediction function \code{x(times, pouter, fixed, ...)} needs to return pinner as attribute,
#' e.g.:\cr
#'  \code{x <- function(times, pouter, fixed=NULL, attach=TRUE, ...) {\cr
#'  out <- lapply(conditions, function(cond) { \cr
#'  pinner <- pL[[cond]](pouter, fixed) \cr
#'  prediction <- xL[[cond]](times, pinner, ...)\cr
#'  observation <- g(prediction, pinner, attach.input = attach)\cr
#'  attr(observation, "pinner") <- pinner\cr
#'  return(observation)\cr
#' }); names(out) <- conditions\cr
#' return(out)}
#' }
#' @param fluxEquations list of chars containing expressions for the fluxes, 
#' if names are given, they are shown in the legend. Easy to obtain via \link{subset.eqnList}, see Examples.
#' @param times Numeric vector of time points for the model prediction
#' @param fixed Named numeric vector with fixed parameters
#'  
#' 
#' @return A plot object of class \code{ggplot}.
#' @examples 
#' \dontrun{
#' plotFluxes(bestfit,times,attr(subset(f,"B"%in%Product), "rates"),nameFlux="B production")
#' }
#' @export
plotFluxes <- function(pouter, x, times, fluxEquations, nameFlux = "Fluxes:", fixed = NULL){
  if(is.null(names(fluxEquations))) names(fluxEquations) <- fluxEquations
  flux <- funC0(fluxEquations)
  prediction.all <- x(times, pouter, fixed, deriv = FALSE)
  
  out <- lapply(names(prediction.all), function(cond) {
    prediction <- prediction.all[[cond]]
    pinner <- attr(prediction,"pinner")
    pinner.list <- as.list(pinner)
    prediction.list <- as.list(as.data.frame(prediction))
    fluxes <- cbind(time=prediction[,"time"],flux(c(prediction.list, pinner.list)))
    return(fluxes)
  }); names(out) <- names(prediction.all)
  out <- wide2long(out)
  
  cbPalette <- c("#999999", "#E69F00", "#F0E442", "#56B4E9", "#009E73", "#0072B2", "#D55E00", "#CC79A7","#CC6666", "#9999CC", "#66CC99","red", "blue", "green","black")
  P <- ggplot(out, aes(x=time, y=value, group=name, fill=name, log="y"))+ ylab("flux") + 
    facet_wrap(~condition) + scale_fill_manual(values=cbPalette, name=nameFlux) +
    geom_density(stat="identity", position="stack", alpha=0.3, color="darkgrey", size=0.4) +
    xlab("time [min]") + ylab("contribution [a.u.]")
  
  return(P)
  
}
