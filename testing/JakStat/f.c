/** Code auto-generated by R2CdeSolve 0.2 **/
#include <R.h> 
 #include <math.h> 
 #include <einspline/nubspline.h> 

static double parms[17];
static double range[2];

#define nGridpoints 101 
#define nSplines 1 
#define precision 1e-05 

#define p1 parms[0] 
 #define p5 parms[1] 
 #define p2 parms[2] 
 #define p3 parms[3] 
 #define p4 parms[4] 
 #define s_STAT parms[5] 
 #define y0_0 parms[6] 
 #define y1_0 parms[7] 
 #define y2_0 parms[8] 
 #define y3_0 parms[9] 
 #define y4_0 parms[10] 
 #define y5_0 parms[11] 
 #define y6_0 parms[12] 
 #define y7_0 parms[13] 
 #define y8_0 parms[14] 
 #define y9_0 parms[15] 
 #define y10_0 parms[16] 
#define tmin range[0]
#define tmax range[1]

static NUBspline_1d_d* dataSpline[nSplines]; 
  
  
 /** spline creation method **/ 
 void createSplines(double *points, double *values) 
 { 
 	int i; 
 	int j; 
 	 
 	BCtype_d xBC = {NATURAL, NATURAL , 0.,0.}; 
 	 
 	double myp[nSplines][nGridpoints]; 
 	double myv[nSplines][nGridpoints]; 
 	 
 	for(i = 0; i < nSplines; i++) { 
 		 
 		for(j=0; j < nGridpoints; j++) { 
 		 
 			myp[i][j] = points[i*nGridpoints + j]; 
 			myv[i][j] = values[i*nGridpoints + j]; 
 			 
 		} 
  
 		NUgrid* mygrid = create_general_grid(myp[i], nGridpoints); 
 		dataSpline[i] = create_NUBspline_1d_d(mygrid, xBC, myv[i]); 
 		 
 	} 
    
   range[0] = points[0]; 
   range[1] = points[nGridpoints-1]; 
  
 } 
  
  
  
  
  
 /** sample function for spline evaluation **/ 
 void evaluateSplines(double* time, double* valueOut, double* gradOut) { 
  	 
 	int i; 
 	double t = *time; 
   double dt = 0.; 
   if(t >= tmax) { 
     dt = t-tmax+precision; 
     t = tmax - precision; 
   } 
   if(t <= tmin) { 
     dt = t-tmin-precision; 
     t = tmin+precision;  
   } 
    
 	 
 	for(i=0; i<nSplines; i++) { 
 		 
 		double value = 0.; 
 		double grad = 0.; 
 	 
 		eval_NUBspline_1d_d_vg(dataSpline[i], t, &value, &grad); 
  
 		gradOut[i] = grad; 
     valueOut[i] = value + dt*grad; 
 		 
 	} 
  
 } 
  
  

void initmod(void (* odeparms)(int *, double *)) {
	 int N=17;
	 odeparms(&N, parms);
}

/** Derivatives (ODE system) **/
void derivs (int *n, double *t, double *y, double *ydot, double *RPAR, int *IPAR) {

	 double x[nSplines];
	 double xdot[nSplines];

	 evaluateSplines(t, x, xdot);

double time = *t;
	 ydot[0] = -1*p1*x[0]*y[0]+1*p5*y[8];
 	 ydot[1] = 1*p1*x[0]*y[0]-2*p2*y[1]*y[1];
 	 ydot[2] = 1*p2*y[1]*y[1]-1*p3*y[2];
 	 ydot[3] = 1*p3*y[2]-1*p4*y[3];
 	 ydot[4] = 2*p4*y[3]-1*p5*y[4];
 	 ydot[5] = 1*p5*y[4]-1*p5*y[5];
 	 ydot[6] = 1*p5*y[5]-1*p5*y[6];
 	 ydot[7] = 1*p5*y[6]-1*p5*y[7];
 	 ydot[8] = 1*p5*y[7]-1*p5*y[8];
 	 ydot[9] = (1)*(-1*p1*x[0]*y[0]+1*p5*y[8])+(1)*(1*p1*x[0]*y[0]-2*p2*y[1]*y[1])+(2)*(1*p2*y[1]*y[1]-1*p3*y[2]);
 	 ydot[10] = 0+(s_STAT)*(1*p1*x[0]*y[0]-2*p2*y[1]*y[1])+(s_STAT*2)*(1*p2*y[1]*y[1]-1*p3*y[2]);

}

